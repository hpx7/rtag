import WebSocket from "ws";
import { Socket } from "net";
import express from "express";
import { createServer } from "vite";
import * as http from "http";
import { dirname, join } from "path";
import { fileURLToPath } from "url";
import { randomBytes } from "crypto";
import Store from "./store";
import { authMiddleware, getUserFromToken } from "./auth";
import { UserData } from "./types";

type StateId = bigint;
type UserId = string;
type Connection = WebSocket & { isAlive: boolean };

const __dirname = dirname(fileURLToPath(import.meta.url));
const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ noServer: true });
const vite = await createServer({
  server: { middlewareMode: "html" },
  root: "{{appEntryPath}}",
  resolve: {
    alias: { vue: "vue/dist/vue.esm.js" },
  },
});

const connections: Map<StateId, Map<UserId, Set<Connection>>> = new Map();
const store = new Store();

app.use(express.json());
app.use(express.raw());
app.post("/new", (req, res) => {
  const token = req.headers.authorization!.split(" ")[1];
  const user = getUserFromToken(token);
  const stateId = randomBytes(8).readBigUInt64LE();
  store.newState(stateId, user, req.body);
  res.json({ stateId: stateId.toString(36) });
});
app.use(authMiddleware());
app.use(vite.middlewares);

server.on("upgrade", (req: http.IncomingMessage, socket: Socket, head: Buffer) => {
  const stateId = [...req.url!.substring(1)].reduce((r, v) => r * BigInt(36) + BigInt(parseInt(v, 36)), 0n);
  wss.handleUpgrade(req, socket, head, (ws) => {
    ws.once("message", (token) => {
      const user = getUserFromToken(token as string);
      handleConnection(stateId, user, Object.assign(ws, { isAlive: true }));
    });
  });
});

const port = process.env.PORT || 3000;
server.listen(port, () => {
  console.log(`listening on http://localhost:${port}`);
});

setInterval(() => {
  connections.forEach((users) => {
    users.forEach((sockets) => {
      sockets.forEach((socket) => {
        if (!socket.isAlive) {
          socket.terminate();
        } else {
          socket.isAlive = false;
          socket.ping(() => {});
        }
      });
    });
  });
}, 30000);

function handleConnection(stateId: StateId, user: UserData, socket: Connection) {
  addConnection(stateId, user, socket);
  socket.on("close", () => {
    deleteConnection(stateId, user, socket);
  });
  socket.on("pong", () => {
    socket.isAlive = true;
  });
  socket.on("message", (data) => {
    store.handleUpdate(stateId, user, data as Buffer);
  });
}

function addConnection(stateId: StateId, user: UserData, socket: Connection) {
  if (!connections.has(stateId)) {
    connections.set(stateId, new Map());
  }
  const users = connections.get(stateId)!;
  if (!users.has(user.id)) {
    users.set(user.id, new Set([socket]));
    store.subscribeUser(stateId, user);
  } else {
    users.get(user.id)!.add(socket);
  }
}

function deleteConnection(stateId: StateId, user: UserData, socket: Connection) {
  connections.get(stateId)!.get(user.id)!.delete(socket);
  if (connections.get(stateId)!.get(user.id)!.size === 0) {
    connections.get(stateId)!.delete(user.id);
    store.unsubscribeUser(stateId, user);
    if (connections.get(stateId)!.size === 0) {
      connections.delete(stateId);
    }
  }
}

export function onNewUserState(stateId: StateId, user: UserData, data: Uint8Array) {
  const users = connections.get(stateId);
  users?.get(user.id)?.forEach((socket) => {
    socket.send(data);
  });
}
